<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Isometric Atlanta — Renderer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #1a1a1a; overflow: hidden; font-family: monospace; }
        canvas { display: block; }

        #info {
            position: fixed;
            top: 12px;
            left: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 6px;
            color: white;
            font-family: monospace;
            font-size: 12px;
            line-height: 1.6;
            pointer-events: none;
            z-index: 100;
        }

        #controls-help {
            position: fixed;
            bottom: 12px;
            left: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 6px;
            color: white;
            font-family: monospace;
            font-size: 11px;
            line-height: 1.5;
            pointer-events: none;
            z-index: 100;
        }

        #attribution {
            position: fixed;
            bottom: 12px;
            right: 12px;
            color: rgba(255,255,255,0.5);
            font-size: 10px;
            max-width: 400px;
            text-align: right;
            z-index: 100;
            pointer-events: none;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255,255,255,0.6);
            font-size: 14px;
            z-index: 200;
        }

        #screenshot-flash {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 300;
            transition: opacity 0.15s ease-out;
        }

        #compass {
            position: fixed;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            width: 80px;
            height: 80px;
            z-index: 100;
            pointer-events: none;
        }

        #compass svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 0 4px rgba(0,0,0,0.5));
        }

        #path-toolbar {
            position: fixed;
            bottom: 12px;
            right: 12px;
            display: flex;
            gap: 6px;
            z-index: 100;
        }

        #path-toolbar button {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 6px 12px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
            cursor: pointer;
            transition: background 0.15s;
        }

        #path-toolbar button:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.15);
        }

        #path-toolbar button:disabled {
            opacity: 0.3;
            cursor: default;
        }

        #path-toolbar button.active {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .waypoint-dot {
            position: fixed;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(231, 76, 60, 0.8);
            border: 2px solid white;
            color: white;
            font-family: monospace;
            font-size: 9px;
            display: flex;
            align-items: center;
            justify-content: center;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 110;
            text-shadow: 0 0 3px rgba(0,0,0,0.8);
        }

        #click-info {
            position: fixed;
            display: none;
            background: rgba(0, 0, 0, 0.85);
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
            line-height: 1.5;
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            z-index: 150;
            pointer-events: none;
            max-width: 300px;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div id="info">
        <div id="coords"></div>
        <div id="zoom-level"></div>
        <div id="tile-count"></div>
        <div id="azimuth-display"></div>
    </div>

    <div id="controls-help">
        Drag / WASD: Pan &nbsp;|&nbsp; Scroll / [ ]: Zoom &nbsp;|&nbsp; Q/E: Rotate 45&deg; &nbsp;|&nbsp; Click: Address &nbsp;|&nbsp; P: Screenshot
    </div>

    <div id="compass">
        <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
            <g id="compass-rose">
                <!-- Outer ring -->
                <circle cx="50" cy="50" r="38" fill="none" stroke="rgba(255,255,255,0.25)" stroke-width="1.5"/>
                <!-- N arrow (red) -->
                <polygon points="50,12 44,42 50,38 56,42" fill="#e74c3c" opacity="0.9"/>
                <!-- S arrow (white) -->
                <polygon points="50,88 44,58 50,62 56,58" fill="rgba(255,255,255,0.4)"/>
                <!-- E tick -->
                <line x1="85" y1="50" x2="78" y2="50" stroke="rgba(255,255,255,0.3)" stroke-width="1.5"/>
                <!-- W tick -->
                <line x1="15" y1="50" x2="22" y2="50" stroke="rgba(255,255,255,0.3)" stroke-width="1.5"/>
                <!-- N label -->
                <text x="50" y="9" text-anchor="middle" fill="#e74c3c" font-size="11" font-family="monospace" font-weight="bold">N</text>
                <!-- Center dot -->
                <circle cx="50" cy="50" r="2.5" fill="rgba(255,255,255,0.5)"/>
            </g>
        </svg>
    </div>

    <div id="click-info"></div>
    <div id="waypoint-container"></div>
    <div id="path-toolbar">
        <button id="path-draw">Draw</button>
        <button id="path-play" disabled>Play</button>
        <button id="path-stop" disabled>Stop</button>
        <button id="path-erase" disabled>Erase</button>
    </div>
    <div id="attribution"></div>
    <div id="loading">Loading 3D Tiles...</div>
    <div id="screenshot-flash"></div>

    <script type="module">
        import * as THREE from 'three';
        import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
        import { TilesRenderer } from '3d-tiles-renderer';
        import { GoogleCloudAuthPlugin, TileCompressionPlugin, GLTFExtensionsPlugin } from '3d-tiles-renderer/plugins';
        import { CONFIG } from './config.js';

        // ============================================
        // WGS84 Ellipsoid constants
        // ============================================
        const WGS84_A = 6378137.0;           // semi-major axis (meters)
        const WGS84_F = 1 / 298.257223563;   // flattening
        const WGS84_B = WGS84_A * (1 - WGS84_F); // semi-minor axis
        const WGS84_E2 = 1 - (WGS84_B * WGS84_B) / (WGS84_A * WGS84_A); // eccentricity squared

        function latLngToECEF(latDeg, lngDeg, alt = 0) {
            const lat = THREE.MathUtils.degToRad(latDeg);
            const lng = THREE.MathUtils.degToRad(lngDeg);
            const sinLat = Math.sin(lat);
            const cosLat = Math.cos(lat);
            const sinLng = Math.sin(lng);
            const cosLng = Math.cos(lng);

            const N = WGS84_A / Math.sqrt(1 - WGS84_E2 * sinLat * sinLat);
            const x = (N + alt) * cosLat * cosLng;
            const y = (N + alt) * cosLat * sinLng;
            const z = (N * (1 - WGS84_E2) + alt) * sinLat;

            return new THREE.Vector3(x, y, z);
        }

        // Build a matrix that transforms ECEF so that a given lat/lng
        // is at the origin with local East = +X, North = +Z, Up = +Y
        function buildECEFToLocalMatrix(latDeg, lngDeg) {
            const ecefPos = latLngToECEF(latDeg, lngDeg);

            // Local coordinate axes at this lat/lng on the ellipsoid
            const lat = THREE.MathUtils.degToRad(latDeg);
            const lng = THREE.MathUtils.degToRad(lngDeg);

            // Up = outward normal (approximated as normalized ECEF position for sphere)
            const up = ecefPos.clone().normalize();

            // East = (-sin(lng), cos(lng), 0) in ECEF
            const east = new THREE.Vector3(-Math.sin(lng), Math.cos(lng), 0).normalize();

            // South = east × up for right-handed system (X=East, Y=Up, Z=South)
            const south = new THREE.Vector3().crossVectors(east, up).normalize();

            // Build rotation: columns are east(X), up(Y), south(Z)
            const rotMatrix = new THREE.Matrix4().makeBasis(east, up, south);
            const rotInverse = rotMatrix.clone().invert();

            // Full transform: translate to origin, then rotate to local frame
            const translateMatrix = new THREE.Matrix4().makeTranslation(
                -ecefPos.x, -ecefPos.y, -ecefPos.z
            );

            return new THREE.Matrix4().multiplyMatrices(rotInverse, translateMatrix);
        }

        // ============================================
        // Scene setup
        // ============================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);

        // Orthographic camera for isometric rendering
        let frustumSize = CONFIG.INITIAL_ZOOM;
        const aspect = window.innerWidth / window.innerHeight;

        const camera = new THREE.OrthographicCamera(
            -frustumSize * aspect / 2,
             frustumSize * aspect / 2,
             frustumSize / 2,
            -frustumSize / 2,
            1,
            100000
        );

        // 2:1 dimetric isometric angle
        // Elevation from ground = arctan(1/2) ≈ 26.565°
        // In Three.js spherical: phi from +Y = arctan(2) ≈ 63.435°
        let azimuthDeg = 0; // North-up
        const cameraDistance = 2000;

        function updateCameraPosition() {
            const phi = Math.atan(2); // elevation: 26.565° from ground
            const theta = THREE.MathUtils.degToRad(180 - azimuthDeg);

            camera.position.setFromSphericalCoords(cameraDistance, phi, theta);
            camera.position.add(panOffset);
            camera.lookAt(panOffset.clone());
            camera.updateProjectionMatrix();
        }

        // Pan offset in world space
        const panOffset = new THREE.Vector3(0, 0, 0);

        function updateFrustum() {
            const a = window.innerWidth / window.innerHeight;
            camera.left = -frustumSize * a / 2;
            camera.right = frustumSize * a / 2;
            camera.top = frustumSize / 2;
            camera.bottom = -frustumSize / 2;
            camera.updateProjectionMatrix();
        }

        updateCameraPosition();

        // Renderer
        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            preserveDrawingBuffer: true // needed for screenshots
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);

        // Lighting — ambient + directional for clear isometric look
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(1, 2, 1);
        scene.add(dirLight);

        // ============================================
        // 3D Tiles setup
        // ============================================
        const tiles = new TilesRenderer();

        // Google Cloud Auth
        tiles.registerPlugin(new GoogleCloudAuthPlugin({
            apiToken: CONFIG.GOOGLE_MAPS_API_KEY,
            autoRefreshToken: true,
        }));

        // Compression for GPU memory
        tiles.registerPlugin(new TileCompressionPlugin());

        // DRACO loader for compressed geometry
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://unpkg.com/three@0.170.0/examples/jsm/libs/draco/gltf/');
        tiles.registerPlugin(new GLTFExtensionsPlugin({
            dracoLoader: dracoLoader,
        }));

        // Error target — higher = fewer tiles loaded (faster), lower = more detail
        tiles.errorTarget = 12;

        // Apply ECEF → local transform
        const localTransform = buildECEFToLocalMatrix(CONFIG.CENTER_LAT, CONFIG.CENTER_LNG);
        // Flip X axis so geographic east renders on the right side of screen
        localTransform.premultiply(new THREE.Matrix4().makeScale(-1, 1, -1));
        tiles.group.matrix.copy(localTransform);
        tiles.group.matrix.decompose(
            tiles.group.position,
            tiles.group.quaternion,
            tiles.group.scale
        );
        tiles.group.matrixAutoUpdate = false;

        scene.add(tiles.group);

        // Connect camera to tiles renderer
        tiles.setCamera(camera);
        tiles.setResolutionFromRenderer(camera, renderer);

        // ============================================
        // Controls
        // ============================================
        const keysDown = new Set();

        let spaceDown = false;

        window.addEventListener('keydown', (e) => {
            keysDown.add(e.key.toLowerCase());

            if (e.key === ' ') {
                e.preventDefault();
                spaceDown = true;
                renderer.domElement.style.cursor = 'grab';
            }

            // Rotate azimuth by 45° increments
            if (e.key.toLowerCase() === 'q') {
                azimuthDeg = (azimuthDeg - 15 + 360) % 360;
                updateCameraPosition();
            }
            if (e.key.toLowerCase() === 'e') {
                azimuthDeg = (azimuthDeg + 15) % 360;
                updateCameraPosition();
            }

            // Screenshot
            if (e.key.toLowerCase() === 'p') {
                takeScreenshot();
            }

            // Zoom with [ and ]
            if (e.key === '[') {
                frustumSize = Math.max(50, Math.min(5000, frustumSize * 0.9));
                updateFrustum();
                updateCameraPosition();
            }
            if (e.key === ']') {
                frustumSize = Math.max(50, Math.min(5000, frustumSize * 1.1));
                updateFrustum();
                updateCameraPosition();
            }
        });

        window.addEventListener('keyup', (e) => {
            keysDown.delete(e.key.toLowerCase());
            if (e.key === ' ') {
                spaceDown = false;
                renderer.domElement.style.cursor = '';
            }
        });

        // Mouse drag to pan
        let isDragging = false;
        let dragMoved = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        renderer.domElement.addEventListener('mousedown', (e) => {
            if (pathMode === 'play') return;
            isDragging = true;
            dragMoved = false;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        window.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {
                    dragMoved = true;
                    renderer.domElement.style.cursor = 'grabbing';
                }
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;

                // Convert pixel delta to world units
                const pixelsPerUnit = window.innerWidth / (frustumSize * (window.innerWidth / window.innerHeight));
                const worldDx = -dx / pixelsPerUnit;
                const worldDy = -dy / pixelsPerUnit;

                // Map screen delta to world XZ using azimuth
                const azRad = THREE.MathUtils.degToRad(180 - azimuthDeg);
                const sinAz = Math.sin(azRad);
                const cosAz = Math.cos(azRad);

                // Screen right → world direction, screen up → world direction
                panOffset.x += worldDx * cosAz;
                panOffset.z += worldDx * -sinAz;
                panOffset.x += worldDy * sinAz;
                panOffset.z += worldDy * cosAz;

                updateCameraPosition();
            }
        });

        window.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                renderer.domElement.style.cursor = '';
            }
        });

        // Zoom with mouse wheel
        window.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
            frustumSize = Math.max(50, Math.min(5000, frustumSize * zoomFactor));
            updateFrustum();
            updateCameraPosition();
        }, { passive: false });

        // Pan with keys each frame
        function handlePan() {
            if (pathMode === 'play') return;
            const panSpeed = frustumSize * 0.008;
            // Pan directions relative to current azimuth
            const azRad = THREE.MathUtils.degToRad(azimuthDeg);
            const forward = new THREE.Vector3(Math.sin(azRad), 0, -Math.cos(azRad));
            const right = new THREE.Vector3(Math.cos(azRad), 0, Math.sin(azRad));

            if (keysDown.has('w') || keysDown.has('arrowup')) panOffset.addScaledVector(forward, panSpeed);
            if (keysDown.has('s') || keysDown.has('arrowdown')) panOffset.addScaledVector(forward, -panSpeed);
            if (keysDown.has('a') || keysDown.has('arrowleft')) panOffset.addScaledVector(right, -panSpeed);
            if (keysDown.has('d') || keysDown.has('arrowright')) panOffset.addScaledVector(right, panSpeed);
        }

        // ============================================
        // Screenshot
        // ============================================
        function takeScreenshot() {
            const flash = document.getElementById('screenshot-flash');
            flash.style.opacity = '0.3';
            setTimeout(() => { flash.style.opacity = '0'; }, 150);

            renderer.render(scene, camera);
            const dataUrl = renderer.domElement.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = dataUrl;
            link.download = `isometric-atlanta-${Date.now()}.png`;
            link.click();
        }

        // ============================================
        // Compass
        // ============================================
        const compassRose = document.getElementById('compass-rose');

        function updateCompass() {
            // Rotate compass so N points toward geographic north on screen
            compassRose.setAttribute('transform', `rotate(${azimuthDeg}, 50, 50)`);
        }
        updateCompass();

        // ============================================
        // Click-to-address (raycast + reverse geocode)
        // ============================================
        const raycaster = new THREE.Raycaster();
        const clickInfoEl = document.getElementById('click-info');
        let clickInfoTimeout = null;

        // Convert local XZ position back to approximate lat/lng
        function localToLatLng(localPos) {
            const centerLatRad = THREE.MathUtils.degToRad(CONFIG.CENTER_LAT);
            const metersPerDegLat = 111320;
            const metersPerDegLng = 111320 * Math.cos(centerLatRad);

            const lat = CONFIG.CENTER_LAT + (localPos.z / metersPerDegLat);
            const lng = CONFIG.CENTER_LNG - (localPos.x / metersPerDegLng);
            return { lat, lng };
        }

        async function reverseGeocode(lat, lng) {
            try {
                const resp = await fetch(
                    `https://maps.googleapis.com/maps/api/geocode/json?latlng=${lat},${lng}&key=${CONFIG.GOOGLE_MAPS_API_KEY}`
                );
                const data = await resp.json();
                if (data.results && data.results.length > 0) {
                    return data.results[0].formatted_address;
                }
            } catch (e) {
                console.warn('Reverse geocode failed:', e);
            }
            return null;
        }

        renderer.domElement.addEventListener('click', async (e) => {
            // Don't fire during drag or playback
            if (dragMoved) return;
            if (pathMode === 'play') return;

            // Normalized device coords
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((e.clientX - rect.left) / rect.width) * 2 - 1,
                -((e.clientY - rect.top) / rect.height) * 2 + 1
            );

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(tiles.group.children, true);

            if (intersects.length > 0) {
                const point = intersects[0].point;

                // Draw mode: add waypoint
                if (pathMode === 'draw') {
                    addWaypoint(point.x, point.y, point.z);
                    return;
                }

                // Normal mode: address lookup
                const { lat, lng } = localToLatLng(point);

                clickInfoEl.style.display = 'block';
                clickInfoEl.style.left = (e.clientX + 12) + 'px';
                clickInfoEl.style.top = (e.clientY - 10) + 'px';
                clickInfoEl.textContent = `${lat.toFixed(5)}, ${lng.toFixed(5)} — loading...`;

                if (clickInfoTimeout) clearTimeout(clickInfoTimeout);

                const address = await reverseGeocode(lat, lng);
                if (address) {
                    clickInfoEl.textContent = `${lat.toFixed(5)}, ${lng.toFixed(5)}\n${address}`;
                    clickInfoEl.style.whiteSpace = 'pre-line';
                } else {
                    clickInfoEl.textContent = `${lat.toFixed(5)}, ${lng.toFixed(5)}`;
                }

                clickInfoTimeout = setTimeout(() => {
                    clickInfoEl.style.display = 'none';
                }, 5000);
            }
        });

        // ============================================
        // Animated Path Mode
        // ============================================
        let pathMode = null; // null | 'draw' | 'play'
        const waypoints = [];
        let pathCurve = null;
        let pathStartTime = 0;
        let pathDuration = 0;
        const PATH_SECONDS_PER_SEGMENT = 4;

        const waypointContainer = document.getElementById('waypoint-container');
        const btnDraw = document.getElementById('path-draw');
        const btnPlay = document.getElementById('path-play');
        const btnStop = document.getElementById('path-stop');
        const btnErase = document.getElementById('path-erase');

        function updatePathButtons() {
            const hasPoints = waypoints.length >= 2;
            const isPlaying = pathMode === 'play';
            const isDrawing = pathMode === 'draw';

            btnDraw.disabled = isPlaying;
            btnDraw.classList.toggle('active', isDrawing);
            btnPlay.disabled = !hasPoints || isPlaying;
            btnStop.disabled = !isPlaying;
            btnErase.disabled = waypoints.length === 0 || isPlaying;
        }

        function enterDrawMode() {
            pathMode = 'draw';
            updatePathButtons();
        }

        function exitDrawMode() {
            pathMode = null;
            updatePathButtons();
        }

        function addWaypoint(worldX, worldY, worldZ) {
            waypoints.push({ x: worldX, y: worldY, z: worldZ });

            // Create dot overlay
            const dot = document.createElement('div');
            dot.className = 'waypoint-dot';
            dot.textContent = waypoints.length;
            dot.dataset.index = waypoints.length - 1;
            waypointContainer.appendChild(dot);

            updatePathButtons();
        }

        function updateWaypointOverlays() {
            if (waypoints.length === 0) return;
            const dots = waypointContainer.children;
            for (let i = 0; i < dots.length; i++) {
                const wp = waypoints[i];
                if (!wp) continue;
                const vec = new THREE.Vector3(wp.x, wp.y, wp.z);
                vec.project(camera);
                const screenX = (vec.x * 0.5 + 0.5) * window.innerWidth;
                const screenY = (-vec.y * 0.5 + 0.5) * window.innerHeight;
                dots[i].style.left = screenX + 'px';
                dots[i].style.top = screenY + 'px';
            }
        }

        function startPlayback() {
            if (waypoints.length < 2) return;

            const points = waypoints.map(wp => new THREE.Vector3(wp.x, 0, wp.z));
            pathCurve = new THREE.CatmullRomCurve3(points, false, 'catmullrom', 0.5);
            pathDuration = (waypoints.length - 1) * PATH_SECONDS_PER_SEGMENT * 1000;
            pathStartTime = performance.now();
            pathMode = 'play';
            updatePathButtons();
        }

        function updatePathAnimation() {
            if (pathMode !== 'play' || !pathCurve) return;

            const elapsed = performance.now() - pathStartTime;
            const t = Math.min(elapsed / pathDuration, 1);

            const pos = pathCurve.getPoint(t);
            panOffset.x = pos.x;
            panOffset.z = pos.z;
            updateCameraPosition();

            if (t >= 1) {
                pathMode = 'draw';
                updatePathButtons();
            }
        }

        function stopPlayback() {
            pathMode = 'draw';
            updatePathButtons();
        }

        function eraseWaypoints() {
            waypoints.length = 0;
            waypointContainer.innerHTML = '';
            pathCurve = null;
            pathMode = null;
            updatePathButtons();
        }

        btnDraw.addEventListener('click', () => {
            if (pathMode === 'draw') {
                exitDrawMode();
            } else {
                enterDrawMode();
            }
        });
        btnPlay.addEventListener('click', startPlayback);
        btnStop.addEventListener('click', stopPlayback);
        btnErase.addEventListener('click', eraseWaypoints);

        // ============================================
        // UI Updates
        // ============================================
        const coordsEl = document.getElementById('coords');
        const zoomEl = document.getElementById('zoom-level');
        const tileCountEl = document.getElementById('tile-count');
        const azimuthEl = document.getElementById('azimuth-display');
        const attributionEl = document.getElementById('attribution');
        const loadingEl = document.getElementById('loading');
        let tilesLoaded = false;

        function updateUI() {
            coordsEl.textContent = `Center: ${CONFIG.CENTER_LAT.toFixed(4)}, ${CONFIG.CENTER_LNG.toFixed(4)}`;
            zoomEl.textContent = `Frustum: ${Math.round(frustumSize)}m`;
            azimuthEl.textContent = `Azimuth: ${azimuthDeg}°`;
            updateCompass();

            const visibleCount = tiles.visibleTiles ? tiles.visibleTiles.size : 0;
            tileCountEl.textContent = `Tiles: ${visibleCount}`;

            // Hide loading indicator once tiles appear
            if (visibleCount > 0 && !tilesLoaded) {
                tilesLoaded = true;
                loadingEl.style.display = 'none';
            }

            // Attribution from Google (required by ToS)
            const plugin = tiles.getPluginByName('GoogleCloudAuthPlugin');
            if (plugin && plugin.getCredits) {
                const credits = plugin.getCredits();
                if (credits && credits.length > 0) {
                    const uniqueCredits = [...new Set(credits.map(c => c.value || c))];
                    attributionEl.textContent = uniqueCredits.join(' | ');
                }
            }
        }

        // ============================================
        // Window resize
        // ============================================
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateFrustum();
            tiles.setResolutionFromRenderer(camera, renderer);
        });

        // ============================================
        // Render loop
        // ============================================
        function animate() {
            requestAnimationFrame(animate);

            handlePan();
            updatePathAnimation();
            updateCameraPosition();

            camera.updateMatrixWorld();
            tiles.update();

            renderer.render(scene, camera);
            updateUI();
            updateWaypointOverlays();
        }

        animate();

        console.log('Isometric Atlanta Renderer initialized');
        console.log(`Center: ${CONFIG.CENTER_LAT}, ${CONFIG.CENTER_LNG} (Centennial Olympic Park)`);
        console.log(`Camera: 2:1 dimetric, azimuth ${azimuthDeg}°`);
    </script>
</body>
</html>
